import codecs


# 类文件开头的固定代码
def getAutoCode(newLine):
    extraStr = \
        '''
import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;

/* AUTO-GENERATED FILE.  DO NOT MODIFY.
 *
 * This class was automatically generated by the
 * SDP AutoR tool . 
 * It should not be modified by hand.
 */
public final class AutoR {
    private static String mPackageName;
    @SuppressLint("StaticFieldLeak")
    private static Context mContext;
    private static volatile boolean RExist;

    public static void init(Context context){
        if (context != null) {
            mContext = context;
            mPackageName = context.getPackageName();
            try {
                Class.forName(mPackageName + ".R");
                RExist = true;
            }
            catch (ClassNotFoundException e) {
                //some game situation
                Log.i("autoR", "No R class");
                RExist =false;
            }
        }else {
            Log.e("autoR","don't init AutoR with null");
        }
    }


    private static int getResId(String resName, String resType) {
        if (mContext != null) {
            //android system resource
            if (!resName.isEmpty() && resName.startsWith("android_")) {
                return mContext.getResources().getIdentifier(resName.replace("android_", ""), resType, "android");
            }
            // R exist
            if (RExist) {
                try {
                    Class<?> cls = Class.forName(mPackageName + ".R$" + resType);
                    return cls.getField(resName).getInt(cls);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    Log.e("autoR", "IllegalAccessException:" + e.getMessage());
                } catch (ClassNotFoundException e) {
                    e.printStackTrace();
                    Log.e("autoR", "ClassNotFoundException:" + e.getMessage());
                } catch (NoSuchFieldException e) {
                    e.printStackTrace();
                    Log.e("autoR", "NoSuchFieldException:" + e.getMessage());
                }
            } else {
                return mContext.getResources().getIdentifier(resName, resType, mPackageName);
            }
        }else {
            Log.e("autoR","you should init AutoR first");
        }
        return 0;
    }
        
        '''
    if newLine != '\n':
        extraStr = extraStr.replace('\n', newLine)
    return extraStr


def convertR(isLibrary, RClassFile, destRClassPackage):
    """
    生成AutoR源码
    :param isLibrary:
    :param RClassFile: 原生的R.java file
    :param destRClassPackage: 目标R的包名
    :return:
    """
    # 获取R类文件中的换行符号
    line_break = '\n'
    # 读取R类文件内容
    fp = codecs.open(RClassFile, 'r', 'utf-8')
    rlines = fp.readlines()
    fp.close()

    # 修改R类package和import和新增的函数
    newRLines = ['package ' + destRClassPackage + ";" + line_break, line_break, getAutoCode(line_break), line_break]

    start = False
    inStyleable = False
    currentResType = None
    if isLibrary:
        resIDPrefix = 'public static int'
    else:
        resIDPrefix = 'public static final int'
    styleableResIDPrefix = 'public static final int[]'
    for index in range(len(rlines)):
        tempLine = rlines[index]
        if start:
            if tempLine.find('=') == -1:
                stripedLine = tempLine.strip()
                if inStyleable:
                    if stripedLine == '};':
                        inStyleable = False
                else:
                    if stripedLine.startswith('public static final class'):
                        currentResType = stripedLine[26:-2].strip()
                    elif stripedLine == '}' or stripedLine == '};':
                        currentResType = None
                    newRLines.append(tempLine)
            else:
                if currentResType is not None:
                    splitLine = tempLine.split('=')
                    leftLine = splitLine[0]
                    resName = splitLine[0].strip()
                    if resName.startswith(styleableResIDPrefix):
                        newLine = leftLine.rstrip()
                        newRLines.append(newLine + line_break)
                        if not tempLine.strip().endswith('};'):
                            inStyleable = True
                    else:
                        if currentResType != 'styleable':
                            resName = resName[len(resIDPrefix):].strip()
                            newLine = leftLine.rstrip() + ' = getResId("' + resName + '", "' + currentResType + '");'
                            newRLines.append(newLine + line_break)
                        else:
                            newRLines.append(tempLine)
        else:
            if tempLine.strip().startswith('public final class R {'):
                start = True
    newRLines = processComment(newRLines)
    processStyleable(newRLines, resIDPrefix, styleableResIDPrefix, line_break)
    return newRLines


# 删除自动生成的注释
def processComment(RLines):
    isInComment = False
    newRLines = []
    for fileLine in RLines:
        if not isInComment:
            if fileLine.lstrip().startswith('/**'):
                isInComment = True
            else:
                newRLines.append(fileLine)
        if isInComment:
            if fileLine.rstrip().endswith('*/'):
                isInComment = False
    return newRLines


# 处理Styleable类型资源
def processStyleable(newRLines, resIDPrefix, styleableResIDPrefix, newl):
    for index in range(len(newRLines)):
        tempLine = newRLines[index]
        splitLine = tempLine.split('=')
        leftLine = splitLine[0]
        resName = splitLine[0].strip()
        if resName.startswith(styleableResIDPrefix):
            resName = resName[len(styleableResIDPrefix):].strip()
            styleableDict = {}
            nextIndex = index
            while True:
                nextIndex += 1
                nextLine = newRLines[nextIndex]
                parsedLine = parseStyleableLine(nextLine, resName, resIDPrefix)
                if parsedLine is None:
                    break
                styleableDict[parsedLine[0]] = parsedLine[1]
            allStyleable = ""
            for temp in range(len(styleableDict)):
                attrResName = styleableDict[str(temp)]
                getResCommand = 'getResId("' + attrResName + '",' + '"attr"' + ')'
                # allStyleable = allStyleable + "attr." + styleableDict[str(temp)]
                # if temp != len(styleableDict) - 1:
                if allStyleable != "":
                    allStyleable = allStyleable + ", " + getResCommand
                else:
                    allStyleable = getResCommand
            newLine = leftLine.rstrip() + ' = { ' + allStyleable + ' };' + newl
            newRLines[index] = newLine


# 处理Styleable类型资源
def parseStyleableLine(styleableLine, styleableName, resIDPrefix):
    if styleableLine.find('=') == -1:
        return
    splitLine = styleableLine.split('=')
    resName = splitLine[0].strip()
    if not resName.startswith(resIDPrefix):
        return
    resName = resName[len(resIDPrefix):].strip()
    if not resName.startswith(styleableName):
        return
    resName = resName[len(styleableName):]
    if not resName.startswith('_'):
        return
    resName = resName[1:]
    resValue = splitLine[1].strip()
    if not resValue.endswith(';'):
        return
    resValue = resValue[:-1]
    return resValue, resName
